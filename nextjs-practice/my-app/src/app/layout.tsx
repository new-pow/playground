import type {Metadata} from "next";
import {Geist, Geist_Mono} from "next/font/google";
import "./globals.css";
import Link from "next/link";
import {router} from "next/client";
import {Control} from "@/app/control";
// TS71001: "useEffect" is not allowed in Server Components.
// 기본적으로 Client Component 라고 간주한다.

// 공통된 내용을 관리
const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

const geistMono = Geist_Mono({
    variable: "--font-geist-mono",
    subsets: ["latin"],
});

// 메타데이터 설정
// TS71008: The Next.js 'metadata' API is not allowed in a client component.
export const metadata: Metadata = {
    title: "Web Tutorial",
    description: "Generated by iirin",
};

export default async function RootLayout({children}: Readonly<{
    children: React.ReactNode;
}>) {
    // 어떻게 동작하는가?
    const resp = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/topics`);
    // 받아온 데이터를 캐싱하고 있다. 갱신에 따라 다시 받아오려면 어떻게 해야할까?
    // docs -> caching 확인하기

    // fetch API를 사용하여 서버에 데이터를 요청한다.
    // fetch API는 Promise를 반환한다.
    // await 키워드를 사용하여 fetch API가 반환하는 Promise가 처리될 때까지 기다린다.
    const topics = await resp.json();
    // 자바스크립트 코드를 빼고 데이터만 받아온다. 용량에 유리
    // 서버쪽에서 렌더링을 끝내고 보내기 때문에 클라이언트는 정적인 페이지를 받아온다.
    return (
        <html lang="en">
        <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <h1><Link href="/">WEB</Link></h1>
        <ol>
            {topics.map((topic: { id: number; title: string; }) => {
                return (
                    <li key={topic.id}>
                        <Link href={`/read/${topic.id}`}>{topic.title}</Link>
                    </li>
                );
            })}
        </ol>
        {children}
        <Control/>
        </body>
        </html>
    );
}
// Link 컴포넌트는 클라이언트 사이드 라우팅을 제공한다.
// 클라이언트 사이드 라우팅은 페이지 이동 시 페이지 전체를 새로 불러오지 않고 필요한 부분만 불러와서 페이지를 변경하는 방식이다.
// 이미 불러온 페이지를 재사용하기 때문에 빠르게 페이지를 이동할 수 있다.
// 이것을 SPA(Single Page Application)라고 한다. Next.js는 기본적으로 SPA를 지원한다.
